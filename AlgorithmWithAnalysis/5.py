# 9월 26일 4주차 알고리즘으로 배우는 수치해석

## 알고리즘은 컴퓨터가 일을 처리할 수 있는 순서를 보여주는 것
## 사람이 문제를 해결하는 방법은 인공지능에 있어서 가장 기본적인 문제이면서, 해결하지 못하는 어려운 문제
## 딥러닝등의 인공 뉴런을 이용한 강력한 해법들이 등장은 하지만 갈 길이 멀다

# 1. 알고리즘과 반복
# 2. 알고리즘과 갱신
# 3. 수렴과 발산의 의미
# 4. 합(sum)에 대한 의미

## 반복과 갱신은 분리할 수 없는 개념
## 값을 새로운 값으로 바꾸기 위해서는 반드시 반복 필요


# 9월 27일 4주차

## 반복과 갱신의 원리
## 온도를 자동으로 측정하는 시스템은 '온도 측정' 이라는 작업을 반복하고 있는 것
## 결국 반복과 갱신이 끊임없이 진행되어야 시스템이 제 역할을 하는 것

N = 10
xold = 0.1
for k in range(N):
    xnew = 1.5*xold + 1
    e = abs((xnew -xold)/xnew) * 100             #오차율 구하기
    print(f'k = {k+1}, x= {xnew:0.4f}')     #0.4f => 소수점 출력관한것
    print(f'오차율은{e:0.1f}%')               
    print("-------------")
    xold = xnew;                        #할당되어 있던 값을 바꿔주어야 다음 주기에 새로운 값 사용

## 발산?? 위와 같은 경우 N이 무한으로 갈 때, 값이 무한대로 커짐
## 이는 컴퓨터 내부에서 처리할 수 있는 데이터의 길이를 초과하여 에러를 반환
## 이러한 상황을 "발산"(divergence) 이라고 함
## 반대의 경우로 0에 가까워 지는 경우는 "수렴"(convergence) 라고 함
## 발산의 경우 정답을 예측하기 불가능하지만 수렴은 정답을 예측할 수 있게 됨
## 수치해석에서 반복과정을 수행하는 것은 그렇게 할 수록 계산값이 실제에 근접한다고 각정

## 상대 오차 계산법?
## epsilon^(k+1) = |{x^(k+1) - x^(k)}over{x^(k+1)}| X 100
## 수렴정도?
## epsilon => |{x^(k+1) - x^(k)}over{x^(k+1)}|
## 수렴정도에 해당하는 구간은 사용자가 정함



# 합에 대한 알고리즘

x = [-1, 1, 3]
hap = 0

for num in x:
    hap += num;
print(f'hap = {hap}')

# 교재에서는
# x = [-1, 0, 1]
# hap = 0
# for i in range(3):
#     hap = hap + x[i]
# print(f'hap = {hap}');

w = [10, 100, 1000]
x = [-1, 1, 3]
hap = 0
for i in range(len(x)):
    hap += x[i]*w[i]
print(f'hap = {hap}')

